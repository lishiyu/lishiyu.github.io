


<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>  分布式锁之ZK锁 |    white.</title>
  <meta name="description" content="A minimalist theme for hexo.">
  <!-- 标签页图标 -->
  

  <!-- 图标库 -->
  <link href="https://cdn.jsdelivr.net/npm/remixicon@2.2.0/fonts/remixicon.css" rel="stylesheet">
  <!-- 动画库 -->
  
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/fushaolei/cdn-white@1.0/css/animate.css"/>
  
  <!-- css文件 -->
  
<link rel="stylesheet" href="/css/white.css">

  <!-- 代码高亮 -->
  
<meta name="generator" content="Hexo 5.4.2"></head>


<body>

<div class="menu-outer">
    <div class="menu-inner">
      <div class="menu-site-name  animate__animated  animate__fadeInUp">
        <a href="/">
          white.
        </a>
        
      </div>
      <div class="menu-group">
        <ul class="menu-ul">
        
          <a href="/" class="nav-link">
            <li class="menu-li  animate__animated  animate__fadeInUp">
              HOME
            </li>
          </a>
        
          <a href="/archives" class="nav-link">
            <li class="menu-li  animate__animated  animate__fadeInUp">
              BLOG
            </li>
          </a>
        
        
        
          <li class="menu-li animate__animated  animate__fadeInUp" id="mobile-menu">
            <i class="ri-menu-line"></i>
          </li>
        
        </ul>

      </div>

    </div>
</div>
<div id="mobile-main" class="animate__animated  animate__fadeIn">
  <div class="mobile-menu-inner">
    <div class="mobile-menu-site-name animate__animated  animate__fadeInUp">
      <a href="/">
        white.
      </a>
    </div>
    <div class="mobile-menu-group" id="mobile-close">
      <i class="ri-close-line"></i>
    </div>

  </div>

  <div class="mobile-menu-div">
  
    <a href="/" class="mobile-nav-link">
      <div class="mobile-menu-child animate__animated  animate__fadeInUp">
        <span>HOME</span>
      </div>
    </a>
  
    <a href="/archives" class="mobile-nav-link">
      <div class="mobile-menu-child animate__animated  animate__fadeInUp">
        <span>BLOG</span>
      </div>
    </a>
  
  
  </div>


</div>

<div class="body-outer">
  <div class="body-inner">
    
<article class="post-inner">
  <div class="post-content-outer">
    <div class="post-intro">
      <div class="post-title animate__animated  animate__fadeInUp">分布式锁之ZK锁</div>
      <div class="meta-intro animate__animated  animate__fadeInUp">Aug 01 2021</div>
      
    </div>
    <div class="post-content-inner">
      <div class="post-content-inner-space">

      </div>
      <div class="post-content-main animate__animated  animate__fadeInUp">
        <!-- top型目录 -->
        
        <h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在介绍 Zookeeper(下文用 ZK 代替)实现分布式锁的机制之前，先粗略介绍一下 ZK 是什么：</p>
<blockquote>
<p>ZooKeeper 是 Apache 软件基金会的一个软件项目，它为大型分布式计算提供开源的分布式配置服务、同步服务和命名注册。</p>
<p>ZooKeeper 的架构通过冗余服务实现高可用性。</p>
<p>Zookeeper 的设计目标是将那些复杂且容易出错的分布式一致性服务封装起来，构成一个高效可靠的原语集，并以一系列简单易用的接口提供给用户使用。</p>
<p>一个典型的分布式数据一致性的解决方案，分布式应用程序可以基于它实现诸如数据发布/订阅、负载均衡、命名服务、分布式协调/通知、集群管理、Master 选举、分布式锁和分布式队列等功能。</p>
</blockquote>
<p><strong>ZK的一些重要特性：</strong></p>
<ol>
<li>一个leader，多个follower组成的集群；</li>
<li>全局数据一致：每个server保存一份相同的数据副本，client无论连接到哪个server，数据都是一致的</li>
<li>分布式读写</li>
<li>更新请求顺序进行，来自同一个client的更新请求按其发送顺序依次执行</li>
<li>数据更新原子性，一次数据更新要么成功（半数以上节点成功），要么失败</li>
<li>实时性（最终一致性），在一定时间范围内，client能读到最新数据</li>
<li>监听机制</li>
</ol>
<p><strong>ZK的数据模型</strong></p>
<p>
        <span class="lazyload-img-span">
        <img   
           data-src="http://img.litongxue.icu/1151631613061_.pic_hd.jpg" >
        </sapn>
      </p>
<p>ZooKeeper的视图数据结构，很像Unix文件系统，也是树状的，这样可以确定每个路径都是唯一的。zookeeper的节点统一叫做「znode」，它是可以通过「路径来标识」。</p>
<p><strong>znode的4种类型</strong></p>
<p>根据节点的生命周期，znode可以分为4种类型，分别是：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>持久节点(PERSISTENT)</td>
<td>这类节点被创建后，就会一直存在于Zk服务器上。直到手动删除。</td>
</tr>
<tr>
<td>持久顺序节点(PERSISTENT_SEQUENTIAL)</td>
<td>它的基本特性同持久节点，不同在于增加了顺序性。父节点会维护一个自增整性数字，用于子节点的创建的先后顺序。</td>
</tr>
<tr>
<td>临时节点(EPHEMERAL)</td>
<td>临时节点的生命周期与客户端的会话绑定，一旦客户端会话失效(非TCP连接断开)，那么这个节点就会被自动清理掉。zk规定临时节点只能作为叶子节点。</td>
</tr>
<tr>
<td>临时顺序节点(EPHEMERAL_SEQUENTIAL)</td>
<td>基本特性同临时节点，添加了顺序的特性。</td>
</tr>
</tbody></table>
<p><strong>事件监听机制（Watcher）</strong></p>
<ul>
<li>Zookeeper提供了数据的发布/订阅功能，多个订阅者可同时监听某一特定主题对象，当该主题对象的自身状态发生变化时(例如节点内容改变、节点下的子节点列表改变等)，会实时、主动通知所有订阅者。</li>
<li>Zookeeper采用了Watcher机制实现数据的发布/订阅功能。该机制在被订阅对象发生变化时会异步通知客户端，因此客户端不必在Watcher注册后轮询阻塞，从而减轻了客户端压力</li>
<li>watcher机制事件上与观察者模式类似，也可看作是一种观察者模式在分布式场景下的实现方式</li>
</ul>
<h3 id="实现锁原理与方式"><a href="#实现锁原理与方式" class="headerlink" title="实现锁原理与方式"></a>实现锁原理与方式</h3><p>基于ZooKeeper实现分布式锁的步骤如下：</p>
<ol>
<li>当第一个客户端（Client1）请求过来时，Zookeeper客户端会创建一个持久节点（/locks）；</li>
<li>如果这个线程（客户端）想获取锁就在locks目录下创建临时顺序节点；</li>
<li>接着，客户端Client1会查找locks下面的所有临时顺序子节点，判断自己的节点lock1是不是排序最小的那一个，如果是，则成功获得锁；</li>
<li>如果又来一个线程B（客户端Client2）获取锁，它会在locks下再创建一个临时节点lock2</li>
<li>线程B（客户端Client2）获取所有节点，判断自己是不是最小节点，如果不是最小节点，就会设置监听排序比自己靠前一位的节点，此时线程B属于抢锁失败进入等待状态；</li>
<li>线程A处理完或出现故障（如果线程A出现故障，根据临时节点得特性，lock1是会自动删除），删除自己的节点，线程B监听到变更事件，判断自己是不是最小的节点，如果是则获得锁。</li>
</ol>
<p>两种实现原理：</p>
<ol>
<li><p><strong>利用临时节点：</strong></p>
<p>zookeeper的临时节点有两个特性，一是节点名称不能重复，二是会随着客户端退出而销毁，因此直接将key作为节点名称，能够成功创建的客户端则获取成功，失败的客户端监听成功的节点的删除事件<br><strong>缺点</strong>：所有客户端监听同一个节点，但是同时只有一个节点的事件触发是有效的，造成资源的无效调度</p>
</li>
<li><p><strong>利用顺序临时节点：</strong></p>
<p>zookeeper的顺序临时节点拥有临时节点的特性，同时，在一个父节点下创建创建的子临时顺序节点，会根据节点创建的先后顺序，用一个32位的数字作为后缀，我们可以用key创建一个根节点，然后每次申请锁的时候在其下创建顺序节点，接着获取根节点下所有的顺序节点并排序，获取顺序最小的节点，如果该节点的名称与当前添加的名称相同，则表示能够获取锁，否则监听根节点下面的处于当前节点之前的节点的删除事件，如果监听生效，则回到上一步重新判断顺序，直到获取锁。</p>
</li>
</ol>
<h3 id="Curator-介绍"><a href="#Curator-介绍" class="headerlink" title="Curator 介绍"></a><strong>Curator 介绍</strong></h3><p>Curator 是一个 ZK 的开源客户端，也提供了分布式锁的实现。它的使用方式也比较简单：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">InterProcessMutex interProcessMutex = new InterProcessMutex(client,&quot;/anyLock&quot;); </span><br><span class="line">interProcessMutex.acquire(); </span><br><span class="line">interProcessMutex.release(); </span><br></pre></td></tr></table></figure>



<p>其实现分布式锁的核心源码如下：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">private boolean internalLockLoop(long startMillis, Long millisToWait, String ourPath) throws Exception </span><br><span class="line">&#123; </span><br><span class="line">    boolean  haveTheLock = false; </span><br><span class="line">    boolean  doDelete = false; </span><br><span class="line">    try &#123; </span><br><span class="line">        if ( revocable.get() != null ) &#123; </span><br><span class="line">            client.getData().usingWatcher(revocableWatcher).forPath(ourPath); </span><br><span class="line">        &#125; </span><br><span class="line"> </span><br><span class="line">        while ( (client.getState() == CuratorFrameworkState.STARTED) &amp;&amp; !haveTheLock ) &#123; </span><br><span class="line">            // 获取当前所有节点排序后的集合 </span><br><span class="line">            List&lt;String&gt;        children = getSortedChildren(); </span><br><span class="line">            // 获取当前节点的名称 </span><br><span class="line">            String              sequenceNodeName = ourPath.substring(basePath.length() + 1); // +1 to include the slash </span><br><span class="line">            // 判断当前节点是否是最小的节点 </span><br><span class="line">            PredicateResults    predicateResults = driver.getsTheLock(client, children, sequenceNodeName, maxLeases); </span><br><span class="line">            if ( predicateResults.getsTheLock() ) &#123; </span><br><span class="line">                // 获取到锁 </span><br><span class="line">                haveTheLock = true; </span><br><span class="line">            &#125; else &#123; </span><br><span class="line">                // 没获取到锁，对当前节点的上一个节点注册一个监听器 </span><br><span class="line">                String  previousSequencePath = basePath + &quot;/&quot; + predicateResults.getPathToWatch(); </span><br><span class="line">                synchronized(this)&#123; </span><br><span class="line">                    Stat stat = client.checkExists().usingWatcher(watcher).forPath(previousSequencePath); </span><br><span class="line">                    if ( stat != null )&#123; </span><br><span class="line">                        if ( millisToWait != null )&#123; </span><br><span class="line">                            millisToWait -= (System.currentTimeMillis() - startMillis); </span><br><span class="line">                            startMillis = System.currentTimeMillis(); </span><br><span class="line">                            if ( millisToWait &lt;= 0 )&#123; </span><br><span class="line">                                doDelete = true;    // timed out - delete our node </span><br><span class="line">                                break; </span><br><span class="line">                            &#125; </span><br><span class="line">                            wait(millisToWait); </span><br><span class="line">                        &#125;else&#123; </span><br><span class="line">                            wait(); </span><br><span class="line">                        &#125; </span><br><span class="line">                    &#125; </span><br><span class="line">                &#125; </span><br><span class="line">                // else it may have been deleted (i.e. lock released). Try to acquire again </span><br><span class="line">            &#125; </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">    catch ( Exception e ) &#123; </span><br><span class="line">        doDelete = true; </span><br><span class="line">        throw e; </span><br><span class="line">    &#125; finally&#123; </span><br><span class="line">        if ( doDelete )&#123; </span><br><span class="line">            deleteOurPath(ourPath); </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line"> return haveTheLock; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>对于 ZK 分布式锁而言:</p>
<ul>
<li>ZK 天生设计定位就是分布式协调，强一致性。锁的模型健壮、简单易用、适合做分布式锁。</li>
<li>如果获取不到锁，只需要添加一个监听器就可以了，不用一直轮询，性能消耗较小。</li>
</ul>
<p>但是 ZK 也有其缺点：如果有较多的客户端频繁的申请加锁、释放锁，对于 ZK 集群的压力会比较大。</p>

        <!-- 分类文章 -->
        
      </div>
      <div class="post-content-inner-space">
        
          <div class="space-toc-main animate__animated  animate__fadeInUp">
            
           </div>
        
      </div>
   </div>
    <!-- 评论 -->
    
  </div>
</article>
  </div>
</div>



<!-- 如果是home模式的话，不在首页就显示footer，如果不是home模式的话 所有都显示footer -->

  <div class="footer-outer animate__animated  animate__fadeInUp">
    <div class="footer-inner">
    <div class="footer-text">
    <p>Power by <a target="_blank" rel="noopener" href="http://hexo.io/">Hexo</a> Theme by <a target="_blank" rel="noopener" href="https://github.com/FuShaoLei/hexo-theme-white">White</a></p>

    </div>
    <div class="footer-contact">
    <ul class="footer-ul">
        
        <li class="footer-li">
            <a href="https://github.com/FuShaoLei/hexo-theme-white" target="_blank">
                <i class="ri-github-line"></i>
            </a>
        </li>
        
        <li class="footer-li">
            <a href="mailto:1563250958@qq.com" target="_blank">
                <i class="ri-mail-line"></i>
            </a>
        </li>
        
    </ul>
    </div>
    </div>
</div>






<script src="/js/white.js"></script>



</body>
</html>
