


<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>  什么是锁 |    white.</title>
  <meta name="description" content="A minimalist theme for hexo.">
  <!-- 标签页图标 -->
  

  <!-- 图标库 -->
  <link href="https://cdn.jsdelivr.net/npm/remixicon@2.2.0/fonts/remixicon.css" rel="stylesheet">
  <!-- 动画库 -->
  
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/fushaolei/cdn-white@1.0/css/animate.css"/>
  
  <!-- css文件 -->
  
<link rel="stylesheet" href="/css/white.css">

  <!-- 代码高亮 -->
  
<meta name="generator" content="Hexo 5.4.2"></head>


<body>

<div class="menu-outer">
    <div class="menu-inner">
      <div class="menu-site-name  animate__animated  animate__fadeInUp">
        <a href="/">
          white.
        </a>
        
      </div>
      <div class="menu-group">
        <ul class="menu-ul">
        
          <a href="/" class="nav-link">
            <li class="menu-li  animate__animated  animate__fadeInUp">
              HOME
            </li>
          </a>
        
          <a href="/archives" class="nav-link">
            <li class="menu-li  animate__animated  animate__fadeInUp">
              BLOG
            </li>
          </a>
        
        
        
          <li class="menu-li animate__animated  animate__fadeInUp" id="mobile-menu">
            <i class="ri-menu-line"></i>
          </li>
        
        </ul>

      </div>

    </div>
</div>
<div id="mobile-main" class="animate__animated  animate__fadeIn">
  <div class="mobile-menu-inner">
    <div class="mobile-menu-site-name animate__animated  animate__fadeInUp">
      <a href="/">
        white.
      </a>
    </div>
    <div class="mobile-menu-group" id="mobile-close">
      <i class="ri-close-line"></i>
    </div>

  </div>

  <div class="mobile-menu-div">
  
    <a href="/" class="mobile-nav-link">
      <div class="mobile-menu-child animate__animated  animate__fadeInUp">
        <span>HOME</span>
      </div>
    </a>
  
    <a href="/archives" class="mobile-nav-link">
      <div class="mobile-menu-child animate__animated  animate__fadeInUp">
        <span>BLOG</span>
      </div>
    </a>
  
  
  </div>


</div>

<div class="body-outer">
  <div class="body-inner">
    
<article class="post-inner">
  <div class="post-content-outer">
    <div class="post-intro">
      <div class="post-title animate__animated  animate__fadeInUp">什么是锁</div>
      <div class="meta-intro animate__animated  animate__fadeInUp">Aug 20 2021</div>
      
    </div>
    <div class="post-content-inner">
      <div class="post-content-inner-space">

      </div>
      <div class="post-content-main animate__animated  animate__fadeInUp">
        <!-- top型目录 -->
        
        <h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>锁在软件开发中是一个非常重要的概念，尤其是在当今的互联网时代，高并发的场景下，更是离不开锁。</p>
<h3 id="那么锁到底是什么呢？"><a href="#那么锁到底是什么呢？" class="headerlink" title="那么锁到底是什么呢？"></a>那么锁到底是什么呢？</h3><blockquote>
<p>在计算机科学中，<strong>锁</strong>是在执行<strong>多线程</strong>时用于强行限制资源访问的<strong>同步</strong>机制，即用于在<strong>并发控制</strong>中保证对<strong>互斥</strong>要求的满足。</p>
</blockquote>
<h3 id="场景描述"><a href="#场景描述" class="headerlink" title="场景描述"></a>场景描述</h3><p>都去过超市买东西，如果你随身带了包呢，要放到储物柜里。咱们把这个例子再极端一下，假如柜子只有一个，现在同时来了3个人A，B，C，都要往这个柜子里放东西。这个场景就构造了一个多线程，多线程自然离不开锁。如下图所示：</p>
<p>
        <span class="lazyload-img-span">
        <img   
           data-src="http://img.litongxue.icu/DemoFigure.jpg" >
        </sapn>
      </p>
<span id="more"></span>

<p>A，B，C都要往柜子里放东西，可是柜子只能放一件东西，那怎么办呢？这个时候呢就引出了<strong>锁</strong>的概念，3个人中谁抢到了柜子的锁，谁就可以使用这个柜子，其他的人只能等待。比如：C抢到了锁，C可以使用这个柜子。A和B只能等待，等C使用完了，释放锁以后，A和B再争抢锁，谁抢到了，再继续使用柜子。</p>
<h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><p>我们再将上面的场景反应到程序中，首先创建一个柜子的类：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class Cabinet &#123;</span><br><span class="line">    //柜子中存储的数字</span><br><span class="line">    private int storeNumber;</span><br><span class="line">    </span><br><span class="line">    public void setStoreNumber(int storeNumber)&#123;</span><br><span class="line">        this.storeNumber = storeNumber;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public int getStoreNumber()&#123;</span><br><span class="line">        return this.storeNumber;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>柜子中存储的是数字。</p>
<p>然后我们将3个用户抽象成一个类：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class User &#123;</span><br><span class="line">    //柜子</span><br><span class="line">    private Cabinet cabinet;</span><br><span class="line">    //存储的数字</span><br><span class="line">    private int storeNumber;</span><br><span class="line">    </span><br><span class="line">    public User(Cabinet cabinet,int storeNumber)&#123;</span><br><span class="line">        this.cabinet = cabinet;</span><br><span class="line">        this.storeNumber = storeNumber;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //使用柜子</span><br><span class="line">    public void useCabinet()&#123;</span><br><span class="line">        cabinet.setStoreNumber(storeNumber);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在用户的构造方法中，需要传入两个参数，一个是要使用的柜子，另一个是要存储的数字。到这里，柜子和用户都已经抽象成了类，接下来我们再写一个启动类，模拟一下3个用户使用柜子的场景：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class Starter &#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        Cabinet cabinet = new Cabinet();</span><br><span class="line">        ExecutorService es = Executors.newFixedThreadPool(3);</span><br><span class="line">        for (int i = 0; i &lt; 3; i++)&#123;</span><br><span class="line">            final int  storeNumber = i;</span><br><span class="line">            es.execute(()-&gt;&#123;</span><br><span class="line">                User user = new User(cabinet,storeNumber);</span><br><span class="line">                user.useCabinet();</span><br><span class="line">                System.out.println(&quot;我是用户&quot;+storeNumber+&quot;,我存储的数字是：&quot;+cabinet.getStoreNumber());</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        es.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们仔细的看一下这个main函数的过程，</p>
<ul>
<li>首先创建一个柜子的实例，由于场景中只有一个柜子，所以我们只创建了一个柜子实例。</li>
<li>然后我们新建一个线程池，线程池中有3个线程，每个线程执行一个用户的操作。</li>
<li>再来看看每个线程具体的执行过程，新建用户实例，传入的是用户使用的柜子，我们这里只有一个柜子，所以传入这个柜子的实例，然后传入这个用户要存储的数字，分别是1，2，3，也分别对应着用户A，用户B，和用户C。</li>
<li>再调用使用柜子的操作，也就是向柜子中放入要存储的数字，然后立刻从柜子中取出数字，并打印出来。</li>
</ul>
<p>我们运行一下main函数，看看打印的结果是什么？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">我是用户0,我存储的数字是：2</span><br><span class="line">我是用户2,我存储的数字是：2</span><br><span class="line">我是用户1,我存储的数字是：2</span><br></pre></td></tr></table></figure>

<p>从结果中我们可以看出，3个用户在柜子中存储的数字都变成了2。我们再次运行程序，结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">我是用户1,我存储的数字是：1</span><br><span class="line">我是用户2,我存储的数字是：1</span><br><span class="line">我是用户0,我存储的数字是：1</span><br></pre></td></tr></table></figure>

<p>这次又变成了1。这是为什么呢？问题就出在<code>user.useCabinet()</code>这个方法上，这是因为柜子这个实例没有加锁的原因，3个用户并行的执行，向柜子中存储他们的数字，虽然是3个用户并行的同时操作，但是在具体赋值时，也是有顺序的，因为变量<code>storeNumber</code>只占有一块内存，<code>storeNumber</code>只存储一个值，存储最后的线程所设置的值。至于哪个线程排在最后，则完全不确定。赋值语句执行完成后，进入到打印语句，打印语句取<code>storeNumber</code>的值并打印，这时<code>storeNumber</code>存储的是最后一个线程所设置的值，3个线程取到的值是相同的，就像上面打印的结果一样。</p>
<p>那么如何解决这个问题？这就引出了我们本文的重点内容——<strong>锁</strong>。我们在赋值语句上加锁，这样当多个线程（本文当中的多个用户）同时赋值时，谁抢到了这把锁，谁才能赋值。这样保证同一时刻只能有一个线程进行赋值操作，避免了之前的混乱的情况。</p>
<p>那么在程序中如何加锁呢？这就要使用JAVA中的一个关键字了——**<code>synchronized</code>**。<code>synchronized</code>分为<code>synchronized</code>方法和<code>synchronized</code>同步代码块。下面我们看一下两者的具体用法：</p>
<ul>
<li><code>synchronized</code>方法，顾名思义，是把<code>synchronized</code>关键字写在方法上，它表示这个方法是加了锁的，当多个线程同时调用这个方法时，只有获得锁的线程才可以执行。我们看一下下面的例子：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public synchronized String getTicket()&#123;</span><br><span class="line">    return &quot;xxx&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以看到<code>getTicket()</code>方法加了锁，当多个线程并发执行的时候，只有获得到锁的线程才可以执行，其他的线程只能等待。</p>
<ul>
<li>我们再来看看<code>synchronized</code>块，<code>synchronized</code>块的语法是：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">synchronized (对象锁)&#123;</span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们将需要加锁的语句都写在<code>synchronized</code>块内，而在对象锁的位置，需要填写加锁的对象，它的含义是，当多个线程并发执行时，只有获得你写的这个对象的锁，才能执行后面的语句，其他的线程只能等待。<code>synchronized</code>块通常的写法是<code>synchronized(this)</code>，这个<code>this</code>是当前类的实例，也就是说获得当前这个类的对象的锁，才能执行这个方法，这样写的效果和<code>synchronized</code>方法是一样的。</p>
<p>再回到我们的示例当中，如何解决<code>storeNumber</code>混乱的问题呢？咱们可以在设置<code>storeNumber</code>的方法上加上锁，这样保证同时只有一个线程能调用这个方法。如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class Cabinet &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //柜子中存储的数字</span><br><span class="line">    private int storeNumber;</span><br><span class="line"></span><br><span class="line">    public synchronized void  setStoreNumber(int storeNumber)&#123;</span><br><span class="line">        this.storeNumber = storeNumber;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getStoreNumber()&#123;</span><br><span class="line">        return this.storeNumber;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们在set方法上加了<code>synchronized</code>关键字，这样在存储数字时，就不会并行的去执行了，而是哪个用户抢到锁，哪个用户执行存储数字的方法。我们再运行一下main函数，看看运行的结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">我是用户1,我存储的数字是：1</span><br><span class="line">我是用户2,我存储的数字是：2</span><br><span class="line">我是用户0,我存储的数字是：0</span><br></pre></td></tr></table></figure>

<p>由于set方法上加了锁，不会并发的执行这个方法，而是一个线程一个线程的去执行，这样用户存储的数字，和取出的数字就对应上了，不会造成混乱。</p>
<p>最后我们通过一张图上面示例的整体情况。</p>
<p>
        <span class="lazyload-img-span">
        <img   
           data-src="http://img.litongxue.icu/DemoFigure-1.jpg" >
        </sapn>
      </p>
<p>如上图所示，线程A，线程B，线程C同时调用<code>Cabinet</code>类的<code>setStoreNumber</code>方法，线程B获得了锁，所以线程B可以执行<code>setStoreNumber</code>的方法，线程A和线程C只能等待。</p>
<h3 id="锁的基本条件"><a href="#锁的基本条件" class="headerlink" title="锁的基本条件"></a>锁的基本条件</h3><ul>
<li><strong>互斥性：</strong>在同一时刻，一个资源只能由一个线程操作；</li>
<li><strong>可重入性：</strong>同一个线程在外层方法获取锁的时候，再进入该线程的内层方法会自动获取锁；</li>
<li><strong>锁超时：</strong>当大量线程对某一锁竞争时可能导致某些线程在很长一段时间都获取不了锁，在某些场景下可能希望如果线程在一段时间内不能成功获取锁就取消对该锁的等待以提高性能；</li>
<li><strong>高效，高可用：</strong>加锁和解锁需要高效</li>
<li><strong>支持阻塞和非阻塞：</strong><ol>
<li>阻塞调用是指调用结果返回之前，调用者会进入阻塞状态等待。只有在得到结果之后才会返回。</li>
<li>非阻塞调用是指在不能立刻得到结果之前，该函数不会阻塞当前线程，而会立刻返回。</li>
</ol>
</li>
<li><strong>支持公平锁和非公平锁(可选)：</strong><ol>
<li><strong>公平锁</strong> - 公平锁是指 <strong>多线程按照申请锁的顺序来获取锁</strong>。</li>
<li><strong>非公平锁</strong> - 非公平锁是指 <strong>多线程不按照申请锁的顺序来获取锁</strong> 。这就可能会出现优先级反转（后来者居上）或者饥饿现象（某线程总是抢不过别的线程，导致始终无法执行）。</li>
</ol>
</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过上面的场景与示例，我们可以了解多线程情况下，造成的变量值前后不一致的问题，以及<strong>锁</strong>的作用。在使用了锁以后，可以避免这种混乱的现象。</p>

        <!-- 分类文章 -->
        
      </div>
      <div class="post-content-inner-space">
        
          <div class="space-toc-main animate__animated  animate__fadeInUp">
            <ol class="space-toc"><li class="space-toc-item space-toc-level-2"><a class="space-toc-link" href="#%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B"><span class="space-toc-text">代码示例</span></a></li><li class="space-toc-item space-toc-level-2"><a class="space-toc-link" href="#%E6%80%BB%E7%BB%93"><span class="space-toc-text">总结</span></a></li></ol>
           </div>
        
      </div>
   </div>
    <!-- 评论 -->
    
  </div>
</article>
  </div>
</div>



<!-- 如果是home模式的话，不在首页就显示footer，如果不是home模式的话 所有都显示footer -->

  <div class="footer-outer animate__animated  animate__fadeInUp">
    <div class="footer-inner">
    <div class="footer-text">
    <p>Power by <a target="_blank" rel="noopener" href="http://hexo.io/">Hexo</a> Theme by <a target="_blank" rel="noopener" href="https://github.com/FuShaoLei/hexo-theme-white">White</a></p>

    </div>
    <div class="footer-contact">
    <ul class="footer-ul">
        
        <li class="footer-li">
            <a href="https://github.com/FuShaoLei/hexo-theme-white" target="_blank">
                <i class="ri-github-line"></i>
            </a>
        </li>
        
        <li class="footer-li">
            <a href="mailto:1563250958@qq.com" target="_blank">
                <i class="ri-mail-line"></i>
            </a>
        </li>
        
    </ul>
    </div>
    </div>
</div>






<script src="/js/white.js"></script>



</body>
</html>
